# Copyright (C) 2023  Nexedi SA and Contributors.
#
# This program is free software: you can Use, Study, Modify and Redistribute
# it under the terms of the GNU General Public License version 3, or (at your
# option) any later version, as published by the Free Software Foundation.
#
# You can also Link and Combine this program with other software covered by
# the terms of any of the Free Software licenses or any of the Open Source
# Initiative approved licenses and Convey the resulting work. Corresponding
# source of such a combination shall include the source code for all other
# software used.
#
# This program is distributed WITHOUT ANY WARRANTY; without even the implied
# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
#
# See COPYING file for full licensing terms.
# See https://www.nexedi.com/licensing for rationale and options.

# Test to compare disk-space and access-speed of the different ZBlk format options:
#
# 	- ZBlk0
# 	- ZBlk1
# 	- h
# 
# The heuristic 'h' should behave as good as ZBlk0 in case of wide changes
# and as good as ZBlk1 in case of small changes.

import os
import random
import resource
import tempfile
import timeit
import sys
from time import time, sleep

# Add relative module path, to run tests on local code
sys.path.append(os.path.join(os.path.dirname(__file__), '..', '..', '.'))

from golang import defer, func
import numpy as np
import transaction
import ZODB, ZODB.FileStorage

from wendelin.bigarray.array_zodb import ZBigArray

ms = 1e-3

random.seed(10)

# Avoid error due to too many opened file descriptors.
cur_limit = resource.getrlimit(resource.RLIMIT_NOFILE)
new_limit = (cur_limit[1], cur_limit[1])
resource.setrlimit(resource.RLIMIT_NOFILE, new_limit)

storage_path = tempfile.mktemp(prefix='zblkbench')

# Declare test parameters.
zblk_fmt = os.environ.get('zblk_fmt', 'h')
change_percentage_set = tuple(float(n) for n in os.environ.get('change_percentage_set', '0.2').split(','))
change_count = int(os.environ.get('change_count', '1000'))
arrsize = int(os.environ.get('arrsize', '1000000'))

# Utiliy functions

def randarr(size=1000000):
    return np.array([[random.randint(1, 1000), random.randint(1, 1000)] for _ in range(size)])

def setrand(A, blksize_length, change_percentage=1):
    #A[0:size][:] = randarr(size)   XXX  always changes blk #0 only
    size = int(blksize_length * change_percentage)
    blk_index = random.randint(0, int(arrsize / blksize_length) - 1)
    blk_offset = blk_index * blksize_length
    # Ensure we don't always only change the beginning of a block
    blk_offset = blk_offset + random.randint(0, blksize_length - size)
    A[blk_offset:blk_offset+size][:] = randarr(size)
    transaction.commit()

def accessrand(A):
    n = random.randint(0, arrsize)
    #a = A[n:n+size] # XXX no ZODB / data access at all - only creates view
    A[n, 0] # force load of ZBlk data via reading ndarray element

traceload = False
delayload = False
@func
def root(func):
    #print(func)
    storage = ZODB.FileStorage.FileStorage(storage_path)
    stor_load       = storage.load
    stor_loadBefore = storage.loadBefore
    def loadBefore(oid, tid):
        if traceload:
            print 'loadBefore %r %r' % (oid, tid)
        # simulate loading latency as actually seen on NEO.
        # there I was seeing latencies up to _1_ millisecond, but even with
        # "modest" 0.2 ms it really shows in the figures.
        #
        # (activated only during read benchmark to avoid avoid wasting time
        # while preparing data)
        if delayload:
            sleep(0.2 * ms)
        return stor_loadBefore(oid, tid)
    def load(oid):
        1/0 # should not call load at all
        print 'load %r' % oid
        return stor_load(oid)
    storage.loadBefore = loadBefore
    storage.load       = load

    db = ZODB.DB(storage)
    connection = db.open()
    root = connection.root

    defer(connection.close)
    defer(db.close)
    defer(storage.close)

    func(root)

@root
def setup(root):
    root.A = A = ZBigArray(shape=[1, 2], dtype=int, zblk_fmt=zblk_fmt)
    transaction.commit()

@root
def fillup(root):
    A = root.A
    values = [[0, 0] for _ in range(arrsize)]
    A.append(values)
    transaction.commit()

@root
def change(root):
    A = root.A[:]
    blksize_length = root.A.zfile.blksize / 16
    for _ in range(change_count):
        change_percentage = random.choice(change_percentage_set)
        setrand(A, blksize_length, change_percentage)
        transaction.commit()

print("\tZODB storage size: %s MB" % (os.path.getsize(storage_path) / float(10**6)))

@root
def access(root):
    global traceload, delayload
    a = root.A[:]   # create BigArray -> ndarray view only once

    #traceload = True
    delayload = True
    def _():
        #print 'access'
        t0 = time()
        accessrand(a)
        t1 = time()
        #print '%.3f ms' % ((t1-t0)/ms)
    random.seed(10)

    # XXX vvv was measuring combined time of all: open database + setup + access block
    # time = timeit.timeit("access()", "from __main__ import access", number=5000)

    # niter should be small to avoid getting into situation when most blocks becomes loaded into cache
    # and we start to measure time of hot access without any ZODB loading
    niter=10
    taccess = timeit.timeit(_, number=niter) / niter
    print("\tAccess time: %.3f ms / blk  (initially cold; might get warmer during benchmark)" % (taccess/ms))
